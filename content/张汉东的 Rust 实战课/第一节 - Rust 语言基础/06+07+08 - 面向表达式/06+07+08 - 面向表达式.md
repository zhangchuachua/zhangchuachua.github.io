### 06~

> 其实不太懂，「语句」与「表达式」的区别，先记着吧以后懂了在看可能会好一点  
>   
> 表达式就暗含了 Rust 中的「一致性」  

Rust 语言借鉴了「函数式编程」而「函数式编程」是「面向表达式」的，也就是 `整个计算过程是通过计算表达式来求值，而不是通过语句来修改某个状态`

Rust 语言中最基本的两个表达式就是

1. 分号表达式 `;` 行分隔符
2. 花括号 `{}` 块分隔符

既然是表达式，那么就可以产生值

1. 分号表达式 可以产生一种「单元类型」的值，是这样的 `()` 其实就是一个**空的元组**
2. 块表达式 的值就是块内最后一行表达式求值所返回的值

> [!important] 求值规则
> 
>   
>   
> 1. 分号表达式返回值永远是自身的单元类型:  
> `()`  
> 2. 分号表达式只有在块表达式最后一行才会求值，其他时候只作为「连接符」存在  
> 3. 块表达式只对其最后一行表达式求值  

```rs
// 这里的代码虽然看着很抽象，但是其实不会编译报错
// main 函数签名没有明确的指定返回值，所以默认会返回单元类型也就是 ()
fn main() {
    ; // 不是最后一行，所以这个分号表达式不会求值
    ;
    {
        () // 块表达式对最后一行表达式求值，所以这个块表达式的返回值就是 ()2
    }
    {
        ();
        use std::vec::Vec;// 同样是分号表达式，所以返回单元类型
    }
    ();
    &{;};// 这里就相当于一个 &()
    // 不能通过这样的语法来获取 &()
    // &;
    ;
    ; // 这是 main 函数块的最后一行，所以这里的分号表达式的返回值就是 () 与 main 函数的返回值类型一致不会报错
}

fn main() {
	// 这里反而会报错，因为 excepted () found integer
	1
}
```

---

在 Rust 中，除了声明语句(比如 use 声明语句)之外，数组，闭包，流程控制等等基本都是表达式；

- for 循环表达式，不会返回值，默认返回单元类型
- if-else 表达式，不管有多少个分支，都必须返回相同的类型
    
    ```rs
    fn test(a: i16) -> i16 {
    		// 这里会报错，因为前面的 if 返回的是 i16 后面返回的是 &str 不同的分支返回的类型不同，报错
        let f = if a == 0 { a } else { "s" };
    
        1
    }
    ```
    
- match 匹配也是表达式

---

- [ ] 操作符表达式都是有优先级的，那么 Rust 中的优先级是如何的？

---

### 07~ 编译期计算

编译期计算有两种方式：

1. 过程宏 + build 脚本（build.rs）
2. 类似于 cpp 的编译器常量表达式求值

视频中这一节主要介绍了第二种方式

第二种方式的编译期计算主要分为了两大类

1. 常量函数 (const fn)
2. 常量范型 (const generic )

> [!important] 需要先了解两个概念，「
> 
> [常量上下文](https://rustwiki.org/zh-CN/reference/const_eval.html#const-context)」和「[常量表达式](https://rustwiki.org/zh-CN/reference/const_eval.html#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F)」  
>   
> 在「常量上下文」中必须使用「常量表达式」，下面是常见的「常量上下文」；  
>   
> 1. 常量项的定义，  
> `const X: T = …;` 这里的 `...;` 就属于「常量上下文」必须使用「常量表达式」  
> 2. 静态数组的长度表达式,  
> `let arr: [i32; 2] = [1, 2]` 这里的长度 2 就属于「常量上下文」所以也必须使用「常量表达式」  
> 3. 重复的长度表达式；  
> `let arr = [0; 128]` 这里的数组就是重复 128 的 0；这里的 128 就属于「常量上下文」必须使用「常量表达式」  
> 4. 常量项、静态项、枚举判别值；常量项和静态项参考常量上下文对应的链接；这个枚举判别值就是  
> `enum Sex { Male, Female }` 此时 Male 与 Female 都有两个判别值，分别为 0 和 1; 当 `enum Sex { Male = 1, Female }` 此时 Male 和 Female 的判别值为 1 和 2；当 `enum Sex { Male(i32), Female(i32) }` 此时 Male 和 Female 的判别值为 0 和 1；这里的「判别值」就应该属于常量上下文，只能使用「常量表达式」  
>   
> 常量表达式具体的内容看  
> [参考链接](https://rustwiki.org/zh-CN/reference/const_eval.html#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F), 上述的 `const fn` 就可以用作常量表达式;

> ==**「是编译器唯一进行编译期求值的地方，其他地方的常量表达式，编译器不一定会在编译期进行计算」**==  
>   
>   
> ==**「Rust 里大部分表达式都可以用作常量表达式，并不是所有的常量表达式都可以用在常量上下文，因为编译期求值必须得到一个确定性的结果」**==

  

> [!important] 还有一个概念叫做「常量传播」，「常量传播」与编译期计算是不同的
> 
>   
>   
> 1. 常量传播是编译器的一种优化。  
> 2. 常量传播并不能改变程序的任何行为，并且对开发者是隐藏的。  
> 3. 编译期计算则是指编译时执行的代码，必须知道其结果，才能继续执行。  

```rs
fn main() {
  const X: i32 = 3 + 4;// 编译期计算；这里在常量上下文中，不确定会不会发生常量传播
  let x = 4 + 3;// 因为它不在常量上下文，所以不会是编译期计算，但是它可能会在编译期被进行常量传播；把所有 x 的地方都修改为 7
}
```

  

```rs
// 斐波那契数列示例
const fn fib(n: u128) -> u128 {
		// 还定义了一个辅助函数，同样也是 const fn
    const fn helper(n: u128, a: u128, b: u128, i: u128) -> u128 {
        if i <= n {
            helper(n, b, a + b, i + 1)
        } else {
            b
        }
    }
    helper(n, 1, 1, 2)
}
// 常量上下文只能使用常量表达式，这里使用 fib(10) 不会报错；
const X: u128 = fib(10);

fn return_2() { 2 }
// 这里会报错
const Y: i32 = return_2();

fn main() {
    println!("{}", X);
}
```

- [ ] ==编译期计算计算如何实现的？==这个问题在视频中有一些讲解，但是与编译期原理有关，且大部分都是代码不好搬过来，所以作为一个 TODO 以后了解，在「07-语法面面观：面向表达式（中）」

### `while true` 与 `loop`

`while tree` 与 `loop` 在语义上看着是一样的意思，但是在编译的时候是有区别的；比如

```rs
fn main() {
	let a: i32;
	while true {
		a = 1;
		break;
	}
	// 这里会报错，因为 a 没有初始化；这里的报错是在编译期抛出的
	println!("{a}");
	
	let b: i32;
	loop {
		b = 2;
		break;
	}
	// 这里不会报错
	println!("{b}");
}
```

为什么会出现上面代码中的问题呢？

因为 while 绝大多数情况下后面都是一个表达式，而不是一个 `true`；对于这些表达式，编译的时候并不能确定是否为 `true` 也就无法确定 while 里面的代码是否会执行，为了保持语言的一致性，Rust 并没有对 `while true` 进行特殊处理；

所以 `while true` 编译的时候也不能保证代码一定会执行；所以进行了报错；

而 `loop` 不一样，编译时可以确定里面的代码一定会执行的；所以编译器可以确定里面初始化了 b 不会报错；

---

### 常量范型

> 视频的资料中常量范型还没有稳定，这是语言圣经参考：<[https://course.rs/basic/trait/generic.html#const-泛型rust-151-版本引入的重要特性](https://course.rs/basic/trait/generic.html#const-%E6%B3%9B%E5%9E%8Brust-151-%E7%89%88%E6%9C%AC%E5%BC%95%E5%85%A5%E7%9A%84%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7)>

在 Rust 中，`[i32; 2] 与 [i32; 3]` 是不同的类型，所以如果我们的函数需要某个长度的数组，那么类型声明除了引用外应该如何声明呢？这个时候就需要常量范型；

```rs
 // const N: usize 就是常量范型，它可以用来代替数组的长度
fn display_array<T: std::fmt::Debug, const N: usize>(arr: [T; N]) {
    println!("{:?}", arr);
}
fn main() {
    let arr: [i32; 3] = [1, 2, 3];
    display_array(arr);

    let arr: [i32; 2] = [1, 2];
    display_array(arr);
}
```

> [!important] 编译期计算的总结：
> 
>   
>   
> 感觉编译期计算的目的就是为了能够在编译期尽可能多的发现问题；不仅提升了项目的健壮性，减少了开发时遇到问题定位问题所花费的时间，而且因为 Rust 打包较慢在编译期发现问题也节约了时间；  

  

这一集的作业：

- [ ] 在 [crates.io](http://crates.io) 中搜索 `const-sha1` 库看看它的源码实现，看它的内部如何使用 `const fn` 函数的
- [ ] 思考标准库中的 `std::vec::Vec` 的 `new` 方法，为什么是常量函数？这样的好处是什么？

---

### 08~

位置表达式，值表达式，位置上下文，值上下文参考资料：<[https://rustwiki.org/zh-CN/reference/expressions.html](https://rustwiki.org/zh-CN/reference/expressions.html)>

表达式可以分为两大类：

1. 位置表达式，是表示内存位置的表达式；
2. 值表达式，是代表实际值的表达式；

比如 `let answer = 42` 其中 `anwser` 就是位置表达式, `42` 就是值表达式，如下图所示，位

![[Untitled 4.png|Untitled 4.png]]

表达式背后的内存管理

位置表达式, 除了以下的位置表达式，其他的都是值表达式：

1. 局部变量；比如 `let anwser = 42;` answer 是局部变量
2. 静态变量。比如: `static mut LEVELS: u32 = 0;` (static 变量是有内存地址的)
    
    > [!important]
    > 
    > `const A: i32 = 1` 这里的 A 不是一个位置表达式；位置表达式是需要在运行时计算的，而 const 将会在编译时就被计算(**编译期计算**)并分配了一个固定的值，所以不是位置表达式；而 static 虽然有 `'static` 生命周期，但是是一个位置表达式
    
3. 解引用表达式. 比如: `*expr`
4. 数组索引表达式。比如: `expr[expr]`
5. 字段表达式. 比如: `expr.field`
6. 以上表达式加上括号，形成的「括号位置表达式」, 比如: `(expr)`

---

> [!important] 注意：
> 
>   
>   
> 「位置上下文是指需要一个位置表达式的上下文；而值上下文是指一个需要值表达式的上下文；并不是位置表达式所在的区域一定是位置上下文，值表达式一定是值上下文；」  
>   
> 当「位置表达式」在「值上下文」时，就会产生「移动」或「复制」  
>   
> 「位置上下文」会去获取表达式对应的位置值；「值上下文」会去获取表达式对应的值；  
>   
> 暂时还没有遇到过「值表达式」出现在「位置上下文」的情况，但是估计会报错；因为「值表达式」没有位置值  

位置上下文，一共有下面 8 种:

1. 除了赋值左侧的位置上下文之外，还有「复合赋值操作」的左侧，例如: `let mut a = 1; a += 1` 这里面两个位置都是位置上下文；
2. 一元「借用」和「解引用」操作中的操作数所在区域： `let a = &mut 7; *a = 42; let b = &a;` 这里的 `&mut 7` 是一个可变借用，属于位置上下文；然后 `*a` 是解引用属于位置上下文
3. 字段表达式的操作数所在区域: 
    
    ```rs
    struct A {
    	name: &'static str,
    }
    let a = A{ name: "Alex" };
    a.name;// 这里取的是 name 这个属性，所以这个字段这个区域，也就是 name 就属于位置上下文
    ```
    
4. 数组索引表达式的操作数所在区域
    
    ```rs
    let mut a = [1,2,3];
    a[1] = 42;// 这里的 a[1] 就属于一个位置上下文
    ```
    
5. 任意隐式借用操作数所在区域: `let mut v = vec![1,2,3]; v.push(4)` 这里的 push 方法会隐式的借用 `&mut v` 所以这里的 push(4) 就属于位置上下文
6. let 语句初始化: `let a: i32; a = 42` 这里的 `let a: i32;` 初始化位置就是一个位置上下文
7. if let/ while let/ match 的匹配表达式所在区域
    
    ```rs
    let dish = ("ham", "eggs");
    let let ("bacon", b) = dish {// 这里的 ("bacon", b) 就是位置上下文
    	println!("bacon is served with {b}");
    } else {
    	println!("no bacon will be served");
    }
    
    // 同理
    // while let (位置上下文)
    // match (位置上下文)
    ```
    
8. 结构体更新语法中的 base 表达式 (..操作符后面的操作数区域)
    
    ```rs
    let mut base = Point3d { x: 1, y: 2, z: 3 };
    Point3 { y: 0, z: 10, .. base }; 这里的 base 就属于位置上下文  
    ```
    

---

Rust所有权语义在 表达式 上的体现：

当位置表达式出现在了值上下文中：

```rs
fn main() {
    // a 是位置表达式，因为是 42 实现了 Copy, 所以是栈内存
    let stack_a = 42;
    // stack_a 是一个局部变量是一个位置表达式，该区域是一个值上下文；位置表达式出现在值上下文，会发生 Move 或 Copy
    // 因为 stack_a 是一个 i32 实现了 Copy 特征，进行 Copy
    // stack_b 这里是一个位置上下文，位置上下文不会对表达式求值，但是会确定表达式所表示的位置，也就是获取它的位置值，以便在该位置进行操作
    // 所以 stack_b 是一个新的位置，然后 42 就这样被复制然后赋值给新的位置；
    let stack_b = stack_a;
    stack_a; // 再次使用，不会报错

    // a 是位置表达式，未实现 Copy，堆内存
    let heap_a = "hello".to_string();
    // heap_a 是位置表达式，在值上下文中发生 Move
    let heap_b = heap_a;
    heap_a; // 再次使用，报错
}
```

> [!important] Move 也是需要满足前提条件的，具体哪些条件请看：
> 
> [参考资料](https://rustwiki.org/zh-CN/reference/expressions.html#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%8D%E5%88%B6%E8%AF%AD%E4%B9%89%E7%B1%BB%E5%9E%8B)

---

**可变与不可变：**  
  
  
Rust 默认不可变；包括：  

1. 不可变绑定与可变绑定
2. 不可变引用和可变引用；

  

![[Untitled 1.png]]

不可变绑定：上述代码中，**在声明的时候是默认不可变的，这就意味着 answer 背后的内存位置上的数据不允许再次改变；**

当然再次使用 `let answer = 43;` 进行修改；但是在位置上下文哪里我们知道了，这里的 answer 其实是新的位置值了； 只是变量名同名而已；

  

![[Untitled 2 2.png|Untitled 2 2.png]]

可变绑定：使用 `mut` 修饰符即可，**这个 `mut` 修饰符是在位置上下文中使用的；这就意味着，允许修改 answer 背后的内存位置上的数据；**

  

![[Untitled 3 2.png|Untitled 3 2.png]]

不可变引用：默认也是不可变的；

  

```rs
fn main() {
	let mut a = 42;
	let b = &mut a;// 可变引用
}
```